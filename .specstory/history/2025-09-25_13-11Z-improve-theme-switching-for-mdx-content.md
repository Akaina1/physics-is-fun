<!-- Generated by SpecStory -->

<!-- cursor Session 1a91cea6-88ed-4a38-a415-bb5196d91bba (2025-09-25 13:11Z) -->

# Improve theme switching for MDX content (2025-09-25 13:11Z)

_**User (2025-09-25 13:02Z)**_

i have a blog project here that renders MDX conent with complex WASM to Canvas simulations: @page.tsx @MdxComponents.tsx @MdxWrapper.tsx @DoubleSlitFraunhofer.tsx 

I am having issues with laggy theme switching when going between dark/light mode@ThemeToggle.tsx 

On our main blog page where we just render card there is no issues and switching is perfectly smooth; @page.tsx 

So the issue is the MDX conent, can you determine the best solution for this so there is perfectly smooth switching animation even on MDX blog pages with complex content

---

_**Assistant (gpt-5-high)**_

<think><details><summary>Thought Process</summary>**Considering CSS Optimizations**

I’m thinking about ways to improve transitions. One option is to implement view transitions, or alternatively, I could set CSS properties for html and body to avoid transitions across the whole page. We could quickly fade an overlay to hide lags. Pre-layering large fixed backgrounds with transform may also help prevent repaint issues. I’ll need to propose code edits in `ThemeToggle.tsx` and `globals.css`, focusing on affected areas without adding anything unnecessary.
**Addressing Type Safety and Code Improvements**

I need to remember not to use the `<any>` type in the DoubleSlitFraunhofer code, as it violates our rules. While it does currently use `any` to import a wasm module with eslint disabling warnings, I should clarify that we didn’t introduce any new instances of `any`. For now, I’ll focus on implementing the view transition approach. In `ThemeToggle.tsx`, I plan to add a check for `document.startViewTransition` in the onClick and keydown events for the theme toggle.
**Modifying Theme Toggle Function**

I’m considering how to modify the function to toggle the theme using view transitions when supported. The proposed `updateTheme` function checks if `document.startViewTransition` exists. If it does, it wraps the theme application inside that transition to manage the theme transition smoothly. 

However, there's a key point: the current code calls `applyTheme` in the `useEffect` when the theme changes. If I call `applyTheme` within the transition callback, it will trigger changes in state, which is fine. I just need to ensure that class toggles occur within the callback for synchronous updates.
**Refining Theme Application Logic**

I'm considering whether it's okay to call both `applyTheme` and `setTheme` while avoiding duplicate applications of `applyTheme`. At the time of toggling, if view transitions are supported, I might call `document.documentElement.classList.toggle("dark", ...)` directly in the callback to update the class, along with updating localStorage and state immediately.

However, since the current code uses an effect to call `applyTheme`, it might be better to keep the logic in one place. The recommended approach is to maintain that logic in the effect, allowing the view transition callback to only call `setTheme(...)`, but it's tricky since this schedules updates asynchronously.
**Implementing View Transitions and CSS Optimizations**

I'm considering that the `document.startViewTransition` callback can be asynchronous. It takes a snapshot of the DOM state, and we need to ensure that the necessary DOM updates occur inside that callback. To implement the theme toggle effectively, I should directly call `applyTheme(next)` within the callback. Updating localStorage and React state is crucial for the correct transition.

Next, I’ll add CSS rules in `globals.css` for smoother animations and optional features like detecting `prefers-reduced-motion`. I'll also ensure to adjust the MDX components for optimal performance, such as using `contain: paint` and other classes to enhance rendering. The main goal is to maintain a smooth transition experience while adhering to type safety in TypeScript without using `<any>`.
**Optimizing the View Transition and Canvas Handling**

I'm exploring the Tailwind config to see if it includes `will-change` utilities since version 3.3. I plan to set the container class to "isolate will-change-transform," though it might not be necessary with view transitions. We need to make sure the canvas is included in the crossfade, so we'll avoid using 'view-transition-name: none' to prevent flickering. 

I’ll propose modifying `ThemeToggle.tsx` to add global interfaces, a helper function for toggling, and adjustments to extend customization. I also want to ensure the `DoubleSlitFraunhofer.tsx` composes styles effectively without overloading props. Providing clear code snippets demonstrating these changes will be crucial while adhering to the patch-like rules for code references.
**Clarifying Code Modifications**

I'm navigating how to reference and append code effectively. Since the `globals.css` file is long and I don't know exact line numbers, I’ll suggest appending content to the bottom using a Markdown code block, as the new code hasn’t existed yet. For `ThemeToggle.tsx`, I need to provide code references for the lines being modified but can’t easily show new inserted lines.

I’ll show the changed context while ensuring accuracy, like indicating the button markup changes. I must also propose adding a global interface for `Document` and a function called `toggleTheme`. This function will handle view transitions, with specific checks for supports and adjustments for existing effects.
**Outlining Theme Transition Changes**

I’m considering changes to the `ThemeToggle.tsx` file to enhance theme transitions. I’ll modify the effect to keep applying the theme without the 'changing-theme' class. Instead, I’ll set a simpler effect to update the local storage and the theme.

For `globals.css`, I plan to add CSS for view transitions that respect user preferences.

Next, I'll also propose edits to the `DoubleSlitFraunhofer` component to isolate heavy canvases and show minor style adjustments. Finally, I’ll deliver these modifications neatly while following the formatting requirements.
**Crafting ThemeToggle Modifications**

I'm proposing changes to `ThemeToggle.tsx` by adding TypeScript declarations at the top. I’ll include a `toggleTheme` function that utilizes view transitions when available, simplifying theme swapping without the 'changing-theme' class. 

I’ll adjust the useEffect to focus solely on applying the theme and updating local storage. Additionally, I’ll modify how the `DoubleSlitFraunhofer` component handles styles to ensure smoother rendering.

Lastly, I’ll update `globals.css` to add view transition properties while ensuring minimal disruption to existing styles. Let’s summarize the changes clearly!
**Providing Smooth Theme Transition Guidance**

I want to make sure to clarify that the code facilitates smooth transitions, particularly in Chrome and Edge, with Safari falling back to immediate toggles, which is fine. I’ll confirm that the `applyTheme` function exists earlier in the file. 

As a precaution, I’ll add type declarations for the Document interface to avoid TypeScript compile errors when referencing `document.startViewTransition`. 

Lastly, I'll recommend reverting any use of the 'changing-theme' CSS, even though it’s currently unused. Let's finalize the response with minimal yet helpful explanations!</details></think>

---

### Plan
- Use the View Transitions API to crossfade the whole page during theme switches (single GPU composited animation → smooth, even with heavy MDX/WASM).
- Remove the temporary `changing-theme` class logic.
- Keep your existing memoization; additionally isolate the canvas to its own paint layer to minimize repaint cost.

### Edits

Add View Transition types near the top of `ThemeToggle.tsx` (after imports):
```ts
declare global {
  interface ViewTransition {
    ready: Promise<void>;
    finished: Promise<void>;
    updateCallbackDone: Promise<void>;
    skipTransition: () => void;
  }
  interface Document {
    startViewTransition?: (cb: () => void | Promise<void>) => ViewTransition;
  }
}
```

Replace the effect that toggles the `changing-theme` class with a simpler one that only applies theme and persists it:
```28:47:src/app/_components/ui/ThemeToggle.tsx
  useEffect(() => {
    applyTheme(theme);
    window.localStorage.setItem(STORAGE_KEY, theme);
  }, [theme]);
```

Add a view-transition-powered toggle function inside the `ThemeToggle` component (place it above the `return`):
```ts
const toggleTheme = (next: Theme) => {
  if (typeof document === "undefined") {
    setTheme(next);
    return;
  }
  const reduceMotion = window.matchMedia("(prefers-reduced-motion: reduce)").matches;
  if (document.startViewTransition && !reduceMotion) {
    document.startViewTransition(() => {
      // Apply DOM change inside the callback so the browser snapshots properly
      applyTheme(next);
      window.localStorage.setItem(STORAGE_KEY, next);
      setTheme(next);
    });
  } else {
    // Fallback
    setTheme(next);
  }
};
```

Use the new toggle in the button handlers:
```66:77:src/app/_components/ui/ThemeToggle.tsx
  return (
    <button
      type="button"
      role="switch"
      aria-checked={isDark}
      onClick={() => toggleTheme(isDark ? "light" : "dark")}
      onKeyDown={(e) => {
        if (e.key === " " || e.key === "Enter") {
          e.preventDefault();
          toggleTheme(isDark ? "light" : "dark");
        }
      }}
```

Isolate the simulation container to reduce repaint work (keeps it on its own layer during theme change):
```72:75:src/app/_components/sims/DoubleSlitFraunhofer.tsx
  return (
    <div className="rounded-xl border border-border bg-card p-3" style={{ contain: "paint", willChange: "transform" }}>
      <div className="mb-3 text-sm text-muted-foreground">
```

Append to the bottom of `globals.css` to tune the transition:
```css
@media (prefers-reduced-motion: no-preference) {
  html::view-transition-old(root),
  html::view-transition-new(root) {
    animation-duration: 220ms;
    animation-timing-function: ease-in-out;
  }
}
```

### Why this fixes the jank
- View Transitions snapshots old/new states and crossfades them on the GPU, avoiding mass color transitions and repaints across MDX content and the large canvas.
- Removing `changing-theme` eliminates extra style recalcs.
- `contain: paint` + a dedicated layer on the canvas further reduces repaint pressure.

### Quick test
- Switch themes on the MDX page with the simulation; you should see a smooth crossfade with no stutter.
- Verify fallback works on browsers without View Transitions (instant switch, no errors).

- Added GPU-accelerated theme switching via View Transitions in `ThemeToggle.tsx`.
- Removed `changing-theme` toggling; still persist and apply theme reliably.
- Isolated the canvas container with `contain: paint` to minimize repaints.
- Added small CSS to control the view transition timing.

---

